# Eval: স্ট্রিং হতে কোড এক্সিকিউট

বিল্ট-ইন `eval` ফাংশন স্ট্রিংকে কোড হিসেবে রানের সুবিধা প্রদান করে।

এর সিনট্যাক্স হল:

```js
let result = eval(code);
```

যেমন:

```js run
let code = 'alert("Hello")';
eval(code); // Hello
```

একটি স্ট্রিংয়ে অনেক কোড যেমন লাইন ব্রেক ফাংশন, ভ্যারিয়েবল ডিক্লেয়ারেশন ইত্যাদি থাকতে পারে।

`eval` এর ফলাফল হবে সর্বশেষ স্টেটমেন্টের ফলাফল।

যেমন:
```js run
let value = eval('1+1');
alert(value); // 2
```

```js run
let value = eval('let i = 0; ++i');
alert(value); // 1
```

eval কোড এক্সিকিউশন লেক্সিকাল এনভায়রনমেন্টের কোডকে এক্সিকিউট করে, সুতরাং এটি এর বাইরের ভ্যারিয়েবলকে দেখতে পারে:

```js run no-beautify
let a = 1;

function f() {
  let a = 2;

*!*
  eval('alert(a)'); // 2
*/!*
}

f();
```

এটি আউটার ভ্যারিয়েবলের মান পরিবর্তনও করতে পারে:

```js untrusted refresh run
let x = 5;
eval("x = 10");
alert(x); // 10, value modified
```

`strict` মোডে, `eval` এর নিজস্ব লেক্সিকাল এনভায়রনমেন্ট থাকে। সুতরাং eval এর কোডকে এর বাইরে থেকে অ্যাক্সেস করা যাবে না:

```js untrusted refresh run
// reminder: 'use strict' is enabled in runnable examples by default

eval("let x = 5; function f() {}");

alert(typeof x); // undefined (no such variable)
// function f is also not visible
```

`use strict` ছাড়া, `eval` এর নিজস্ব লেক্সিকাল এনভায়রনমেন্ট থাকে না, সুতরাং `x` এবং `f` কে বাহির থেকে অ্যাক্সেস করতে পারব।

## "eval" এর ব্যবহার

মডার্ন জাভাস্ক্রিপ্টে `eval` তেমন ব্যবহার করা হয় না। এটি সম্পর্কে বলা হয় "eval is evil"।

প্রায় এক দশক আগে জাভাস্ক্রিপ্ট একটি দুর্বল প্রোগ্রামিং ল্যাঙ্গুয়েজ ছিল, সে সময় বিভিন্ন কাজ করতে আমরা  `eval` ব্যবহার করতাম।

এখন, `eval` ব্যবহারের কোন কারণ নেই। এর পরিবর্তে আমরা মডার্ন ল্যাঙ্গুয়েজ কন্সট্রাক্ট বা [JavaScript Module](info:modules) ব্যবহার করি।

দয়া করে মনে রাখুন আউটার ভ্যারিয়েবল অ্যাক্সেস থাকার কারণে বিভিন্ন সমস্যা হতে পারে।

প্রোডাকশনের জন্য আমরা কোড মিনিফাই করার সময় এরা লোকাল ভ্যারিয়েবলগুলোকে শর্ট ভ্যারিয়েবল দ্বারা প্রতিস্থাপন করে (যেমন `userData` হয়ে যাবে `a`) যাতে আমাদের কোডের সাইজ ছোট হয়। এটি সুবিধাজনক, কিন্তু `eval` যেহেতু তার আউটার স্কোপকে অ্যাক্সেস করতে পারে, `eval` ব্যবহারের সময় লোকাল ভ্যারিয়েবলকে শর্ট ভ্যারিয়েবল প্রতিস্থাপন করে না। যার ফলে মিনিফাই করার সময় ফাইল সাইজের অনুপাতে একটি পার্থক্য দেখা যায়।

এছাড়াও `eval` এ আউটার স্কোপ ভ্যারিয়েবল ব্যবহার ব্যাড প্রাক্টিস, এছাড়াও কোড সহজে পরিবর্তনযোগ্য থাকে না।

এক্ষেত্রে আমরা দুই উপায়ে এটি ব্যবহার করতে পারি।

**যদি এটি আউটার স্কোপের ভ্যারিয়েবল ব্যবহার না করে, তাহলে `eval` এর পরিবর্তে `window.eval(...)` ব্যবহার করুন:**

তাহলে আমাদের কোডটি সর্বদা গ্লোবাল স্কোপে এক্সিকিউট হবে:

```js untrusted refresh run
let x = 1;
{
  let x = 5;
  window.eval('alert(x)'); // 1 (global variable)
}
```

**যদি লোকাল ভ্যারিয়েবল অ্যাক্সেস করা লাগে, তাহলে `eval` এর পরিবর্তে `new Function` এ ভ্যালুটি পাস করার মাধ্যমে ব্যবহার করুন:**

```js run
let f = new Function('a', 'alert(a)');

f(5); // 5
```

`new Function` সম্পর্কে এই অধ্যায়ে আলোচনা করা হয়েছে <info:new-function>। এটি গ্লোবাল স্কোপে স্ট্রিং হতে ফাংশন তৈরি করে, তাই লোকাল ভ্যারিয়েবলকে অ্যাক্সেস করতে পারে না। সুতরাং উপরের উদাহরণের মত আর্গুমেন্ট পাসের মাধ্যমে ভ্যারিয়েবলকে অ্যাক্সেস করতে পারি।

## সারাংশ

`eval(code)` কোন একটি স্ট্রিংয়ের কোডকে এক্সিকিউট করে এবং শেষের স্টেটমেন্টের রেজাল্ট রিটার্ন করে।
- মডার্ন জাভাস্ক্রিপ্টে বলতে গেলে এটি আর ব্যবহার করা হয় না
- আউটার স্কোপে অ্যাক্সেস থাকে, তবে এটিকে ব্যাড প্রাক্টিস হিসেবে বিবেচনা করা হয়
- গ্লোবাল স্কোপের জন্য `eval` এর পরিবর্তে `window.eval(...)` ব্যবহার করি।
- অথবা লোকাল ভ্যারিয়েবল অ্যাক্সেস এর জন্য `eval` এর পরিবর্তে `new Function` এ ভ্যালু পাস করার মাধ্যমে ব্যবহার করি।
